<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c1a5cb044fc31486708abf49cfc71e18</icon>
  <subtitle>Reading, Practising, Thinking, Induction, And Writting.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://raywism.com/"/>
  <updated>2018-10-07T05:32:23.000Z</updated>
  <id>https://raywism.com/</id>
  
  <author>
    <name>Ray Wang</name>
    <email>raywism@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象的 SOLID 原则</title>
    <link href="https://raywism.com/2018/10/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84SOLID%E5%8E%9F%E5%88%99/"/>
    <id>https://raywism.com/2018/10/07/面向对象的SOLID原则/</id>
    <published>2018-10-07T05:22:21.000Z</published>
    <updated>2018-10-07T05:32:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><table><thead><tr><th>缩写</th><th>全称</th><th>中文</th></tr></thead><tbody><tr><td>S</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>O</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>L</td><td>Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>I</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr><tr><td>D</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>一个类只应承担一种责任。换句话说，让一个类只做一件事。如果需要承担更多的工作，那么分解这个类。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>订单和账单上都有流水号、业务时间等字段。如果只用一个类表达，赋予其双重职责，后果:</p><ol><li>特有属性和共有属性相互掺杂，难以理解;</li><li>修改一个场景可能会影响另一个场景。</li></ol><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p>实体应该对扩展是开放的，对修改是封闭的。即，可扩展(extension)，不可修改(modification)。</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>一个商户接入了多个付款方式，支付宝和微信支付，如果将调用支付API的类写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;T&gt; <span class="title">pay</span><span class="params">(Param param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(param.getType() == <span class="string">"ALIPAY"</span>) &#123;</span><br><span class="line">            <span class="comment">// 支付宝付款调用</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(param.getType() == <span class="string">"WeChatPay"</span>) &#123;</span><br><span class="line">           <span class="comment">// 微信支付付款调用</span></span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么每次新加一种支付方式，或者修改原有的其中一种支付方式，都要修改PayHandler这个类，可能会影响现有代码。</p><p>比较好的做法是将不同的行为(支付方式)抽象，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, PayProcessor&gt; processors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;T&gt; <span class="title">pay</span><span class="params">(Param param)</span> </span>&#123;</span><br><span class="line">        PayProcessor payProcessor = processors.get(param.getType());</span><br><span class="line">        <span class="comment">// 异常处理略</span></span><br><span class="line">        <span class="keyword">return</span> payProcessor.handle(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PayProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function">Result&lt;T&gt; <span class="title">handle</span><span class="params">(Param param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlipayProcessor</span> <span class="keyword">implements</span> <span class="title">PayProcessor</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatPayProcessor</span> <span class="keyword">implements</span> <span class="title">PayProcessor</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，新增支付方式只需要新增类，如果使用的是spring等容器，在xml配置对应key-value关系即可；修改已有的支付方式只需要修改对应的类。最大化地避免了对已有实体的修改。</p><h2 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h2><p>一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。换句话说，当子类可以在任意地方替换基类且软件功能不受影响时，这种继承关系的建模才是合理的。</p><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>经典的例子: 正方形不是长方形的子类。原因是正方形多了一个属性“长 == 宽”。这时，对正方形类设置不同的长和宽，计算面积的结果是最后设置那项的平方，而不是长*宽，从而发生了与长方形不一致的行为。如果程序依赖了长方形的面积计算方式，并使用正方形替换了长方形，实际表现与预期不符。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>不能用继承关系(is-a)，但可以用委派关系(has-a)表达。上例中，可以使用正方形类包装一个长方形类。或者，将正方形和长方形作进一步抽象，使用共有的抽象类。</p><h3 id="逸闻"><a href="#逸闻" class="headerlink" title="逸闻"></a>逸闻</h3><p>“里氏”指的是芭芭拉·利斯科夫（Barbara Liskov，1939年－），是美国第一个计算机科学女博士，图灵奖、冯诺依曼奖得主，参与设计并实现了OOP语言CLU，而CLU语言对现代主流语言C++/Java/Python/Ruby/C#都有深远影响。其项目中提炼出来的数据抽象思想，已成为软件工程中最重要的精髓之一。（来源: 互动百科）</p><h2 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h2><p>客户(client)不应被强迫依赖它不使用的方法。即，一个类实现的接口中，包含了它不需要的方法。将接口拆分成更小和更具体的接口，有助于解耦，从而更容易重构、更改。</p><h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><p>仍以商家接入移动支付API的场景举例，支付宝支持收费和退费；微信接口只支持收费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PayChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refund</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlipayChannel</span> <span class="keyword">implements</span> <span class="title">PayChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChatChannel</span> <span class="keyword">implements</span> <span class="title">payChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有任何代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种支付渠道，根本没有退款的功能，但是由于实现了PayChannel，又不得不将refund()实现成了空方法。那么，在调用中，这个方法是可以调用的，实际上什么都没有做!</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>将PayChannel拆成各包含一个方法的两个接口PayableChannel和RefundableChannel。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><ol><li>高层次的模块不应依赖低层次的模块，他们都应该依赖于抽象。</li><li>抽象不应依赖于具体实现，具体实现应依赖抽象。<br>实际上，依赖倒置是实现开闭原则的方法。</li></ol><h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p>开闭原则的场景仍然可以说明这个问题。以下换一种表现形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;T&gt; <span class="title">pay</span><span class="params">(Param param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(param.getType() == <span class="string">"ALIPAY"</span>) &#123;</span><br><span class="line">            AlipayProcessor processor = <span class="keyword">new</span> AlipayProcessor();</span><br><span class="line">            processor.hander(param);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(param.getType() == <span class="string">"WeChatPay"</span>) &#123;</span><br><span class="line">            WeChatPayProcessor processor = <span class="keyword">new</span> WeChatPayProcessor();</span><br><span class="line">            processor.hander(param);</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlipayProcessor</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatPayProcessor</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这种实现方式，PayHandler的功能(高层次模块)依赖了两个支付Processor(低层次模块)的实现。</p><h3 id="扩展：IOC和DI"><a href="#扩展：IOC和DI" class="headerlink" title="扩展：IOC和DI"></a>扩展：IOC和DI</h3><p>控制反转(IOC)和依赖注入(DI)是Spring中最重要的核心概念之一，而两者实际上是一体两面的。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><ul><li>一个类依赖另一个类的功能，那么就通过注入，如构造器、setter方法等，将这个类的实例引入。</li><li>侧重于实现。</li></ul><h4 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h4><ul><li>创建实例的控制权由一个实例的代码剥离到IOC容器控制，如xml配置中。</li><li>侧重于原理。</li><li>反转了什么：原先是由类本身去创建另一个类，控制反转后变成了被动等待这个类的注入。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;全称&lt;/th&gt;
&lt;th&gt;中文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://raywism.com/tags/Java/"/>
    
      <category term="面向对象" scheme="https://raywism.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="设计模式" scheme="https://raywism.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>解决「微信公众号」开发网页安卓端访问空白问题</title>
    <link href="https://raywism.com/2018/09/10/%E8%A7%A3%E5%86%B3%E3%80%8C%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E3%80%8D%E7%BD%91%E9%A1%B5%E5%AE%89%E5%8D%93%E7%AB%AF%E8%AE%BF%E9%97%AE%E7%A9%BA%E7%99%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://raywism.com/2018/09/10/解决「微信公众号」网页安卓端访问空白问题/</id>
    <published>2018-09-10T08:16:41.000Z</published>
    <updated>2018-09-10T08:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司的项目使用基于 Vue 的 Vux 框架，开发微信公众号 Web 端，部署至生产环境后发现一个问题。</p><p>同事使用安卓机访问公众号，图片迟迟不能加载，Web 页面显示空白。</p><p>经过排查发现是使用 Let’s Encrypt TLS 证书导致的。</p><p>贴出<strong>错误</strong>的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    listen       [::]:80 ssl;</span><br><span class="line">    server_name  maseratinetworkchina.com;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/maseratinetworkchina.com/cert.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/maseratinetworkchina.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为<strong>正确</strong>的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    listen       [::]:80 ssl;</span><br><span class="line">    server_name  maseratinetworkchina.com;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/maseratinetworkchina.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/maseratinetworkchina.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是cert.pem、chain.pem以及fullchain.pem的区别：</p><table><thead><tr><th>文件名</th><th>内容</th></tr></thead><tbody><tr><td>cert.pem</td><td>服务端证书</td></tr><tr><td>chain.pem</td><td>浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</td></tr><tr><td>fullchain.pem</td><td>包括了cert.pem和chain.pem的内容</td></tr><tr><td>privkey.pem</td><td>证书的私钥</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近公司的项目使用基于 Vue 的 Vux 框架，开发微信公众号 Web 端，部署至生产环境后发现一个问题。&lt;/p&gt;
&lt;p&gt;同事使用安卓机访问公众号，图片迟迟不能加载，Web 页面显示空白。&lt;/p&gt;
&lt;p&gt;经过排查发现是使用 Let’s Encrypt TLS 证书导致的。
      
    
    </summary>
    
      <category term="微信开发" scheme="https://raywism.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    
      <category term="Https 证书" scheme="https://raywism.com/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/Https-%E8%AF%81%E4%B9%A6/"/>
    
    
      <category term="微信" scheme="https://raywism.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="Nginx 配置" scheme="https://raywism.com/tags/Nginx-%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Https 证书" scheme="https://raywism.com/tags/Https-%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
</feed>
